# Graph library #

## Что реализовано? ##

<p>В данной библиотеке содержится реализация класса графа, bfs(обхода в ширину), dfs(обхода в глубину), а также алгоритмов основанных на последнем.</p>

## Детали реализации ##

### Класс <code>Graph</code> ###

<p>Класс содержит методы получения кол-ва вершин и списка инцидентных вершин.</p>
<p>Реализованы два его субкласса: </p>

*<code>MatrixOfEdges</code> -- хранит граф в виде матрицы инцидентности
*<code>ListOfEdges</code> -- хранит информаци в виде списка рёбер

<p>Чтобы начать работу с графом необходимо вызвать метод std::unique_ptr<Graph> MakeCompactGraph(size_t number_of_vertices, 
        const std::vector<Edge>& edges) из <code>"graph.h"</code>.</p>
<p>Данный метод возвращает умный указатель на один из субклассом, руководствуясь экономией памяти на хранение графа.</p>

<p>Примечание: вершины должны быть пронумерованы от нуля до количества минус один.</p>

### BFS ###

<p>Нерекурсивный обычный bfs. Возвращает вектор длин в кол-вах рёбер от старта.</p>

### DFS ###

<p>Реализован нерекурсивный dfs, принимающий кроме экземпляра графа ещё и наследников <code>DFSVisitor</code>.</p>

<p>Во время работы dfs, вершины могут иметь три состояния:</p>
*WHITE -- вершина ещё не обрабатывалась*
*GREY -- обработка вершины ещё не завершена
*BLACK -- вершина обработана

<p>Примечание: обработка вершины -- запуск dfs от неё.<>

<p>В <code>DFSVisitor</code> возможно переопределить три метода:</p>
*<code>void BeforeProcessing(size_t vertex)</code> -- вызывается dfs-ом до обработки вершины
*<code>void ProcessIncidenceVertex(size_t edge_begin, size_t edge_end, colors end_color)</code> -- вызывается dfs-ом при попытке* перехода от вершины к вершине
*<code>virtual void AfterProcessing(size_t vertex)</code> -- вызывается dfs-ом после обработки вершины

<p>Примечание: попытка перехода -- переход в белую или просмотр серой или черной из данной вершины.</p>

### Алгоритмы основанные на dfs ###

* <code>2_sat_solution.h</code> -- решение задачи 2_sat
* <code>graph_has_cycle.h</code> проверка на наличие цикла в графе
* <code>condense_graph.h</code> -- конденсация графа
* <code>Tarjan's_strongly_connected_components_algorithm.h</code> -- алгоритм Тарьяна
* <code>topological_sort.h</code> -- топологическая сортировка

## Тесты ##

<p>Не unit тесты используют в качестве входных данных различные виды графов из "graph_generate.h":</p>
* пустые графы
* полные графы
* ацикличные графы
* функциональные графы
* случайные графы

### Класс Graph ###
* unit тесты для двух наследников
* тест оптимальности выбора представления графа методом MakeCompactGraph
* тест размера используемой памяти (результаты в логах) на различных видах графов

### Метод bfs ###
* unit тесты

### Метод dfs ###
* тесты корректности переходов и обработки всех вершин
* тест времени работы (в логах) на различных видах графов

### 2_sat ###
* тесты на решаемых входных данных
* тесты на нерешаемых входных данных
* тесты на случайных входных данных

### Конденсация графа ###
* unit тесты

### Алгоритм Тарьяна ###
* тест на всех графах до 5 вершин
* тест на стабильность -- результат не меняется от порядка входных данных
* тест на случайных графах

### Топологическая сортировка ###
* тесты на различных видах графов